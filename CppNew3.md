# 现代C++新特性之匿名函数和STL

## 匿名函数

​	匿名函数又称lambda表达式，可以看成是一般函数的函数名略去，返回值使用-> 表示。与普通函数不同的地方在于增加了"捕获列表"。

```c++
// [捕获列表](参数列表)->返回类型 { 函数体 }
void func() {
    //定义匿名函数
    auto add = [](int a, int b)->int {
        return a+b;
    };
    //使用匿名函数
    std::cout << add(1, 1) << endl;
}
```

​		编译器也可能自动推导出lambda表达式的返回类型，所以放回类型可以省略。

```c++
// [捕获列表](参数列表){ 函数体 }
void func() {
    //定义匿名函数
    auto add = [](int a, int b) {
        return a+b;
    };
    //使用匿名函数
    std::cout << add(1, 1) << endl;
}
```

- 值捕获和引用捕获。

  ​	lambda的捕获列表可以按照值进行捕获，也可以捕获引用。

```c++
void func() {
    int a = 10;
    int b = 20;
    //定义匿名函数
    auto add = [a, &b]()->int {
        std::cout << a <<endl;
        std::cout << b << endl;
        // 内部修改 b ，外部的b也会修改。 
        return a + b;
    };
    a = 30;
    b = 40;
    //使用匿名函数
    std::cout << add() << endl;
    // a 是值捕获， 所以打印出 a 还是 10。
    // b 是捕获引用， 所以打印出 b 是 40。
    // 函数返回值为50。
}
```

-  隐式捕获和空捕获。

  ​	有时参数非常多，手动写捕获列表非常繁琐，就可以交给编译器进行隐式捕获。捕获列表中写`&`  代表捕获所有变量的引用，`=` 代表值捕获所有变量。

```c++
// [捕获列表](参数列表)->返回类型 { 函数体 }
void func() {
    int a = 10;
    int b = 20;
    auto add1 = [&]()->int { // 捕获所有变量的引用
        return a+b;
    };
    
    auto add1 = [=]()->int { // 捕获所有变量的值
        return a+b;
    };
    
    auto add1 = []()->int { // 空捕获，无法使用外部的值，编译错误 ！
        return a+b;
    };
    int c = 30;
    int d = 40;
     //引用捕获a、b,值捕获c、d
    auto add1 = [&, c, d]()->int {
        return a+b;
    };
     //值捕获a、b,引用捕获c、d
    auto add1 = [=, &c, &d]()->int { 
        return a+b;
    };
    
}
```

- 表达式捕获。

  ​	上面提到的值捕获和引用捕获，都是捕获已经在外层作用域声明的变量，因此这种捕获的都是**左值**，而**不能捕获右值**。

  ​	C++14 之后支持捕获右值，允许捕获的成员用任意的表达式进行初始化，被声明的捕获变量类型会根据表达式进行判断，与类型推导auto本质是相同的。

  ```c++
  void func() {
      auto a = std::make_unique<int>(10);
      // 捕获右值
      auto add = [v1 = 20, v2 = std::move(a)](int x, int y)->int {
          return x + y + v1 + (*v2);
      };
      //使用匿名函数
      std::cout << add(1, 1) << endl;
      // 输出32。
  }
  ```

- 泛型Lambda。

  ​	在C++14 之前，lambda表达式的形参只能指定具体类型，没办法泛化。C++14开始，lambda可以使用auto实现泛型。

  ```c++
  void func() {
      auto add = [](auto x, auto y)->int {
          return x + y;
      };
      //使用匿名函数,整型和浮点型。
      std::cout << add(1, 2) << endl;
     	std::cout << add(1.1, 2.2) << endl;
  }
  ```

- 可变lambda

  ​	采用值捕获的，lambda不能修改其值，如果想修改，使用mutable修饰。引用捕获的lambda可以直接修改值。

  ```c++
  void func() {
      int a = 10;
      auto add = [a]() mutable {
          a++;
          return a;
      };
      a = 20;
     	std::cout << add() << endl; // 打印 11。
  }
  
  void func() {
      int a = 10;
      auto add = [a]() mutable {
          a++;
          return a;
      };
      a = 20; 
     	std::cout << add() << endl; // 打印 21。
  }
  ```

  ### 总结

  1. 捕获列表为[names]，names是逗号分隔的列表，这些是lambda所在函数的局部变量，默认按值拷贝传递，如果名字前面加了&，则传递引用。
  2. 捕获列表为[&]，外部所有变量都按引用传递给lambda使用。
  3. 捕获列表为[=]，外部所有变量都按值传递给lambda使用。
  4. 匿名函数定义的时候对于按值传递的捕获列表，**会立即将当前取到的值拷贝一份作为常数**，然后该常数作为参数传递。
  5. 捕获列表为[& , lists]，lists是逗号分隔的列表，该类别的变量按值捕获，其他变量按引用隐式捕获，lists中的名字前面**不能**使用`&`。
  6. 捕获列表为[= , lists]，lists是逗号分隔的列表，该类别的变量按引用方式捕获，其他变量按值隐式捕获，lists中的名字前面**必须**使用`&`，并且不能包含this。



## STL

​	STL 定义了强大的、基于模板的、可复用的组件，实现了许多通用的数据结构和处理这些数据结构的算法。其中包括了三个部分-- 容器、迭代器、算法。

​	STL 容器可以分为四类：序列容器、有序关联容器、无序关联容器、容器适配器。

​	序列容器描述了线性的数据结构，关联容器描述非线性。容器适配器是在序列容器的基础上加上一定的约束条件得到。

**序列容器**

| 标准库容器类 | 描述                                       |
| ------------ | ------------------------------------------ |
| array        | 固定大小，直接访问元素                     |
| deque        | 从头部或尾部进行快速插入和删除操作         |
| forward_list | 单链表，在任意位置插入和删除               |
| list         | 双向列表，在任意位置插入和删除             |
| vector       | 从后部快速插入和删除，可以直接访问任意元素 |



**有序关联容器**（键按顺序存储）

| 标准库容器类 | 描述                                   |
| ------------ | -------------------------------------- |
| set          | 集合，无重复元素，快速查找             |
| multiset     | 集合，有重复元素，快速查找             |
| map          | KV键值对，无重复元素，基于键快速查找   |
| multimap     | KV键值对，可有重复元素，基于键快速查找 |



**无序关联容器**

| 标准库容器类       | 描述                                   |
| ------------------ | -------------------------------------- |
| unordered_set      | 集合，无重复元素，快速查找             |
| unordered_multiset | 集合，有重复元素，快速查找             |
| unordered_map      | KV键值对，无重复元素，基于键快速查找   |
| unordered_multimap | KV键值对，可有重复元素，基于键快速查找 |



**容器适配器**

| 标准库容器类   | 描述                             |
| -------------- | -------------------------------- |
| stack          | 栈，后进先出（LIFO）             |
| queue          | 队列，先进先出(FIFO)             |
| priority_queue | 优先级队列，优先级最先的元素先出 |



### 有序关联容器和无序关联容器区别

- 有序关联容器内部是红黑树，红黑树具有自动排序的功能，因此有序关联容器内部的所有元素都是有序的，红黑树的每一个节点都代表了一个元素。
- 无序关联容器内部实现是哈希表，查找复杂度可达到O(1)，所以排列顺序是无序的。
- 无序关联容器的内存占用略高，但是执行效率比有序关联容器高很多。

